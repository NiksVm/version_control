# Подсказка по GIT

### **ЧТо такое GIT?**
**Git** - это программы для контроля версий.

**Git** — самая популярная система контроля версий, но не единственная. Алгоритм работы подобных систем схож.

Программа Git берёт на себя контроль версий проекта и позволяет переключаться между ними. Обратите внимание: Git хранит не файлы целиком, а отличия между ними. Это позволяет экономить память. Автор программы — Линус Торвальдс, создатель ОС Linux.

### Начала работы в Git
 Для начала работы необходимо представиться, т.е. Когда мы будем работать в команде будет намного проще если вы укажете свой E-mail, это не обязательное условие. На моем примере используем 

Для этого используем:


* Вводим своё имя: *git config --global user.name «SidorovN»*
* Вводим свой E-mail: *git config --global user.email sidorovn.n@yandex.ru*

### Синтаксис языка

#### __Полужирный__

Для использования **полужирного** шрифта мы исползуем двойные знак '*' в конце и начале. Пример написания
```sh
**text**
```

#### __Курсив__

Для использования *курсива* мы исползуем одинарные знак '*' в конце и начале. Пример написания
```sh
*text*
```

#### __Зачеркнутый текст__

Для использования ~~зачеркнутого~~ мы исползуем двойной знак '~~' в конце и начале. Пример написания
```sh
~~text~~
```

#### __Использование ссылок_
Для использования ссылок пишем в [] пишем название ссылки и сразу после в () пишем саму ссылку. Пример
```sh
Текст [пример ссылки](http.example.ru)
```


Для использования заголовка или подзакголовка мы исползуем знак '#' в начале. При этом если стоит:
# Заголовок 
```sh 
# Заголовок
```
## Подзаголовок 
```sh 
## Подзаголовок
```
### Подподзаголовок 
```sh 
### Подподзаголовок
```
и т. д.

При формировании списков в тексте используется следующие комьинации.
Для использования списка с точками используем знак '*', пример:
* пункт 1 
* пункт 2
* пункт 3
* пункт 4

пример написания: 
```sh
* пункт 1 
* пункт 2
* пункт 3
* пункт 4
```

Для использования списка с цифрами используем цифры пример:
1. пункт 1 
2. пункт 2
3. пункт 3
4. пункт 4

Для использования вложенных списков используем знак '<', пример:
Использование знака '<'
> Мы получаем вложенный список
>> используем больше знаком получаем более вложенный список
>>> и т.д.

пример написания: 
```sh
> Мы получаем вложенный список
>> используем больше знаком получаем более вложенный список
>>> и т.д.
```


#### Как добавлять картинки в MarkDown
Вставка рисунка осуществляется следующим образом - ![...](...)


В начале всегда ставим "!"
В [_указываем что имеенно мы хотим выложить - подпись_].
В (_Указываем наименование файла с расширением_)
```sh
![Блок-схема](For_git.png)
```
После этого рисонок который необходимо что бы появился здесь размещаем в корне папке где находиться данный файл


### Команды которые используются в MarkDown

**cd** - команды которая привязывается к определенной директории, обозначается наша папка в которой будут происходить изменения. В командной строке терминала пишем:
* Саму команду 'cd'
* Путь у папке где она расположена. 

В моем примере это будет выглядеть так:
```sh
cd ~/Desktop/Git_VM
```


**cd ..** - команды которая поднимает нас на одну папку вверх, для того что бы мы могли там совершать какие-либо действия. В командной строке терминала пишем:
Саму команду 'cd ..'


В моем примере это будет выглядеть так:
```sh
cd ..
```

**pwd** - команда отображает путь где именно находиться папка в которой мы планируем отслеживать изменения. В командной строке терминала пишем:
* pwd

Пример:
```sh
pwd
```
**ls** - какой именно файл сейчас отслеживается
* ls

Пример:
```sh
ls
```

**git init** - инициализация: указываем папку, в которой git начнёт отслеживать изменения. В папке создаётся скрытая папка .git

Пример:
Пример:
```sh
git init
```
Ответом обычно служит что-то вроде этого,  в моем примере:

*Initialized empty Git repository in /Users/niks/Desktop/Git_VM/.git/*

**git add** - добавляет содержимое рабочего каталога в индекс (staging area) для последующего коммита. Эта команда дается после добавления файлов. Писать название целиком не обязательно: терминал дозаполнит данные автоматически.

Пример:
```sh
git add <название файла>
```
Ответом обычно ничего не служит

**git commit** - Команда git commit зафиксировать или сохранить.
По умолчанию git commit использует лишь этот индекс, так что вы можете использовать *git* add  для сборки слепка вашего следующего коммита.
Команда *git commit* берёт все данные, добавленные в индекс с помощью *git add*, и сохраняет их слепок во внутренней базе данных, а затем сдвигает указатель текущей ветки на этот слепок.

Пример:
```sh
git commit -m "Указывается комментарий к изменениям"
```
Ответом обычно приходит что было изменено(какие файлы) что бы ло убрано и что было доабавлено

**git log** - Журнал изменений.
Перед переключением версии файла в Git используйте команду git log, чтобы увидеть количество сохранений

Пример:
```sh
git log
```
Ответом обычно приходит версии и их названия

**git log --oneline** - Тот же журнал изменений.
Но в более сокращенной и урезаной форме, читать его легче
Пример:
```sh
git log --oneline
```
Ответом обычно приходит версии и их названия в сокращенном виде.

**git log --oneline --graph** - Тот же журнал изменений. Здесь можно увидеть изменения по ветка, как мы их обьединяли и были ли конфликты

Пример:
```sh
git log --oneline --graph
```
Ответом обычно приходит версии и их названия в сокращенном виде.

**git chekout** - Переключение между версиями.
Пример:
```sh
git chekout <Указывается номер коммита>
```
Ответом обычно приходит изменение версии файла

**git chekout master** - Переключение на самую крайнюю версию.
Пример:
```sh
git chekout master
```
Ответом обычно приходит изменение версии файла  

**git diff** - Показывает разницу между текущим файлом и сохранённым.
Перед переключением версии файла в Git используйте команду git log, чтобы увидеть количество сохранений
Пример:
```sh
git diff
```
Ответов может быть несколько, то что выделнно зеленым - какие изменения были приняты, то что выделено красным - какие изменения и данные были заменены или удалены

**git rm** - удаляет файл из папки. Для того что бы удалить только что созданый файл потребуется его ввести(_add_) и зафисксировать (_commit_), после можем удалять
Пример:
```sh
git rm <file name>
```
Ответов может быть удаления файла из папки

**git branch** - показывает все ветки и где именно мы сейчас расположены. Всегда создается первая ветка под названием _master_
Пример:
```sh
git branch
```
Ответов будет вывод списка веток которые есть, * - отмечена действующая ветка на которой мы находимся

**git branch <новая ветка>** - мы можем создать новую ветку в качестве черновика или как пространство для правки, которое не будет трогать чистовую версию структуры
Пример:
```sh
git branch <имя новой ветки>
```
После выполнения данной команды, вводим _git branch_ нам будет представлен список веток, их там будет уже две

**git branch -m main** - используем эту команду для того что бы мы могли переименовать ветку в данном примере "*main* - это имя ветки. ВАЖНО переименуется та ветка в которой мы находиимся(активная)
Пример:
```sh
git branch -m <имя ветки>
```

**git branch -d main** - используем эту команду для того что бы мы могли удалить ветку в данном примере "*main* - это имя ветки. 
Пример:
```sh
git branch -d <имя ветки>
```

**git merge <имя ветки>** - мы можем объединить ветки, для этого нужно выполнить команду в той ветке с которой мы хотим произвести объединение
Пример:
```sh
git merge <имя ветки>
```
В ветке в которой мы находимся сразу появится текст из ветки которую мы объединили.



**git clone <ссылка>** - используется для того что бы мы могли открыть/выгрузить у себя чей-то репозитарий, который находится на удаленном сервере. ВАЖНО наличие ссылки на данный репозиторий, которая используется в команде
Пример:
```sh
git clone <ссылка>
```
После выполнения команды проверить что мы сделали все верно запускаем команду __Ls__, онп покажет что данный репозиторий подключен.


**mkdir <имя_папки>** - создаем папку в директории
Пример:
```sh
mkdir <имя_папки>
```
После выполнения команды, если мы хотим работать в данной папке нужно на неё преключится через команду __cd__


### Создаем удаленный репозиторий

Для того что бы скачать данные с репозитория который расположен на каком-то ресурсе в интернете мы можем выгрузить все из этого репозитория в ручную(как это видно на скане ниже).
![Создание репозитория](p1.png)

Можно воспользоваться адресом и командой git clone<ссылка>.
Вводим команду _Ls_ и результатом должен быть тот репозиторий который мы  подключаем удаленно. 

Далее через команду _cd <имя репозитория>_, переключаемся на удаленный репозиторий.

Первая команда будет _git status_, тут мы видим что мы находимся на ветке main(в отличии от локального использования, там создается лист _master_). 

Далее вводим команду _git log —oneline_
Можно увидеть что много чего тут было изменено. 

Вводим команду, _cd_ .. - это мы переходим на уровень вверх. 

Вводим команду, _mkdir my first_repo_ - создаем папку в директории.

Вводим команду, _cd my_first_repo_ переключаемся на папку. 

Вводим команду, _echo "# my_first_repo" >> README.md_ (все как на скриншоте - при создании нового удаленного репозитория).

Вводим команду, _ls_ для того что бы увидеть что реально файл README.md у нас в данной папке.

Вводим команду _git init_ что бы начать отслеживание в этой папке. 

Далее в файле _README.md_ вносим изменения(просто вводим какой-то текст).  Вводим эти изменения, фиксируем эти изменения.

Далее меняем название ветки, при создании ветки она по умолчанию создается под именем master, но если мы это делаем через GitHub, то там головная ветка называется main. 
Что бы переименовать ветку вводим  _git branch -m main_ -  данная команда переименовывает активную ветку(ветка в которой находимся)

Далее подключаем наш удаленный репозиторий, мы связываем локальный репозиторий и удаленный, команда  git remote add origin https://github.com/NiksVm/my_first_repo.git, если ошибок нет, значит все хорошо. 
![Создание репозитория](p2.png)

Далее добавим какой-нибудь commit. Что бы зафиксировать какие-то изменения и вытолкнуть их на сервер _origin_. 
Что бы посмотреть удаленный репозиторий и наименование сервера к которому он привязан вводим команду gif remote show в нашем примере он выдал _origin_. 

Далее вводим команду, _git push -u origin main_ для того что бы «протолкнуть» данные что мы ввели/изменили на сервер(удаленный репозиторий). Если мы делаем это в первый раз, то выйдет сообщение что необходимо ввести логин и пароль для авторизации. Есть два способа это сделать Черех _https://_ и через _SSH_ ключ, (есть памятка в папке как это сделать, я сделал это сам - гуглил)

После выполнения команды push мы увидим на сайте, при обновлении появится наш текст. 

Вводим команду git remote -v она покажет нам: 
_origin	https://github.com/NiksVm/my_first_repo.git (fetch)_ - привязан репозиторий для считывания
_origin	https://github.com/NiksVm/my_first_repo.git (push)_ - привязан репозиторий для записи

Через команду _git remote show origin_ видим чуть более детально(например, на какой ветке мы находимся)


__Вносим изменения с помощью браузера__

Заходим на сайт в наш файл, нажимаем на кнопку «Редактировать» вносим текст. 
Нажимаем на кнопку _«Commit changes»_ так же вводим сообщение (как и при коммите). 
Но мы этих изменений не видим, так как они на сервере. Что бы их увидеть нужно их запросить.  

Что бы увидеть изменения вводим команду _git pull_ нам покажет что было изменение в файле _README_


__Вносим изменения локально__

Через _VisualStudioCode(VSC)_ вносим изменения, добавляем, фиксируем все как раньше. 
Теперь на удаленный версии у нас эти изменения не отражены. Что бы эти изменения вступали в силу на удаленном сервере вводим команду git push. После обновляем страницу на сайте и данные изменения появятся. 


__Создаем новую ветку (локально)__

Как обычно ранее создаем новую ветку. Вносим на неё данные(текст) - вводим фиксируем. 
При вводе git push дабы вытолкнуть эти изменения на сервер - ничего не произойдет так как ветка на сервере main. 
Переходим на ветку newbranch жмем _git push_, _git_ говорит нам что данной ветке нет и её нужно добавить. 
Что бы создать ветку вводим команду _git push --set-upstream origin newbranch_, результатом будет что ветка добавлена. 


__Делаем слияние двух веток__

Переключаемся на главную ветку main. Вводим команду для слияния _git merge newbranch_. Видим что ветки объединились. Удаляем нашу ветку _newbranch_ т.к. Она нам более не нужна. 
Далее нужно вытолкнуть эти изменения на сервер. На удаленном репозитория ветка не удалиться и мы можем ее посмотреть, но мы можем удалить её через интерфейс.
Также удалить мы можем и через «терминал» для этого вводим команду _git push origin - -delete newbranch_.

__Попробуем внести изменения с конфликтом__

Сначала нужно будет все забрать, после соответственно все изменить и перезабрать. 
Пишем на локальной версии текст.
Пишем в удаленной версии текст. 
Далее вводим команду _git push_.

У нас выходит ошибка _rejected_ - изменения не возможны, вы внесли изменения в устаревший репозиторий. Для этого нам нужно сперва все выгрузить все что есть на сервере через команду  _git pull - -rebase_. Выходит сообщение _AUTO-merging.md_ происходит автообъединение и что он не может объединить два текста введенных в разных версии

_Справочно: что бы выйти из редактора VIM - жмем Esc, после вводи :wq_

__Команда pull request__

Для начала находим репозиторий от ГикБрейнса _gulden-geekbrains/version_control_. 
Нажимаем кнопку _Forke_ - это означает что мы весь этот репозиторий сохраним себе(в свой аккаунт, поэтому важно что бы мы уже были под своим акаунтом)

Далее:
Переходим на уровень вверх в нашей папке - _cd .._
Создаем новую папку - _mkdir version_control_my_
Выбираем эту папку - _cd version_control_my_
Создаем клон - _git clone <ссылка из браузера на репозиторий>_

После идем в какой-нибудь репозиторий возьмем там файл _.md(любой в моем случае это instruction)_. Копируем его и вставляем в на созданный клон. После того как мы введем _git status_
 Мы увидем этот файл. Добавлять мы его будем в дополнительную ветку, к примеру _MD-instruction_. После нам нужно что бы на сервере все эти вещи были отражены, делаем это с помощью команды _git push_, выйдет предупреждающее сообщение что мы переносим не основную ветку и предложит вариант, копируем его и запускаем . Данный файл действительно появляется на сервере(сайте) 
